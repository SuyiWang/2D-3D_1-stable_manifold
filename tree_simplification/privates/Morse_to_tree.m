%%  Discrete morse post processing - enforce a tree structure
%   Input:  'inputs/outvert.txt', 'inputs/outedge.txt'
%           These are two files generated by discrete morse
%   Output: Figure (or .swc file for vaa3D)
%   Dependency: vaa3d_matlab_io (required if using vaa3d), matlab_bgl
%   Downloads: 
%       matlab_bgl: https://www.mathworks.com/matlabcentral/fileexchange/10922-matlabbgl
%       vaa3d_matlab_io: the folder is in vaa3d source code.

%   Morse_to_tree, tree_simplification

function [final_tree, vert, usedidx] = Morse_to_tree(dir_path, input_filename, shift)
    trans = [0 0 0];
    scale = [1 1 1];
    
    if nargin == 0
        % dir_path = '~/Develop/density/Results/AllenInstitute/1/';
        % dir_path = '~/Develop/density/Results/Partha/PMD1228/';
        dir_path = 'inputs/'
        % dir_path = '~/Develop/density/Results/Partha/PMD1232/';
    end
    
    if nargin == 3
        trans = shift;
    end
    addpath('vaa3d_matlab_io');
    addpath('privates');
    addpath('matlab_bgl');


    %%  Read in graph file
    disp('reading graph file');
%     figure(2);
    [vert, G] = Draw1stable([dir_path input_filename{1}],[dir_path input_filename{2}], 'c', 0, false);
    if isempty(G)
        final_tree = [];
        vert = [];
        usedidx = [];
        return
    end
    
    %%  adjust position and scale if necessary
    disp('transforming graph to original space');
    vert = transformvert(vert, trans, scale);


    %%  clean with branch - collapse degree 2 edges
    disp('converting to abstract graph');
    %   ToAbstract_branch(Graph, verbose, vertex_list, use_average)
    [absG, edgeG, edgeList, abs_idx] = ToAbstract_branch(G, 0, vert, 0);
    % DrawGraph(absG, vert(abs_idx,:),'k',1);
    disp('computing maximum spanning tree');
    absT = maxspanningtree(absG);
    % hold on;
    % plot3(vert(abs_idx,1),vert(abs_idx,2),vert(abs_idx,3),'b*');
    % DrawGraph(absT, vert(abs_idx,:),'k',1);
    % hold off;


    %%  smooth each branch
    edgeList = s_branch(edgeList, vert, false);
    edgeList = resample_edge(edgeList);


    %%  expand degree 2 edges
    disp('converting back to actual graph');
    [newG, usedidx] = ToActual(absT, edgeG, edgeList, vert, 0, abs_idx);
    disp('Selecting connected component');


    %%  Through away small connected components
    newG = newG'+newG;
    [ci, sizes] = components(newG);
    disp('# of components:');
    disp(max(ci));
    disp('remove redundant components');
    
    [sorted_size, idx] = sort(sizes, 'descend');
    keepmark = find(sorted_size>00);
    mark = zeros(max(idx), 1);
    mark(idx(keepmark)) = 1;
    [I J V] = find(newG);
    for i = length(I):-1:1
        if (mark(ci(I(i)))==0||mark(ci(J(i)))==0)
            I(i) = []; J(i) = []; V(i) = [];
        end
    end
    newG = sparse(I, J, V, size(vert, 1), size(vert, 1)); %+sparse(J, I, V, n, n);

    
    
    %%  Make up edges
    %   see makeup.m for details
    disp('making up edges');
    restG = logical(absG>1e-6)  - logical(absT>1e-6);
    Gadd = makeup(restG, edgeG, edgeList, vert, 0, abs_idx);


    %%  Plot results
    disp('Plotting result');
%     DrawGraph(G, vert(:, 1:3), 'c', 2);

    if ~isempty(Gadd) && ~isempty(newG)
        final_tree = newG + Gadd;
    else
        final_tree = newG;
    end
    % rand(1,3)
    DrawGraph(final_tree, vert(:, 1:3), rand(1,3), 1);
