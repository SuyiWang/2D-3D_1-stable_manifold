%%  Discrete morse post processing - enforce a tree structure
%   Input:  'inputs/outvert.txt', 'inputs/outedge.txt'
%           These are two files generated by discrete morse
%   Output: Figure (or .swc file for vaa3D)
%   Dependency: vaa3d_matlab_io (required if using vaa3d), matlab_bgl
%   Downloads: 
%       matlab_bgl: https://www.mathworks.com/matlabcentral/fileexchange/10922-matlabbgl
%       vaa3d_matlab_io: the folder is in vaa3d source code.

%   This file is depreacted and will be split into two files:
%   Morse_to_tree, tree_simplification

function Morse_Post(is_tree, dir_path, output_filename, persist, pos, shift)
    handroot = 0;
    trans = [0 0 0];
    scale = [1 1 1];
    if nargin > 5
        handroot = 1;
        trans = -shift;
    end
    addpath('vaa3d_matlab_io');
    addpath('privates');
    addpath('matlab_bgl');


    %%  Read in graph file
    if nargin == 0
        % dir_path = '~/Develop/density/Results/AllenInstitute/1/';
        % dir_path = '~/Develop/density/Results/Partha/PMD1228/';
        dir_path = 'inputs/'
        output_filename = 'Partha_ori.swc';
        is_tree = 0;
        % dir_path = '~/Develop/density/Results/Partha/PMD1232/';
    end
    
    disp('reading graph file');
    figure(1);
    if is_tree == 1
        dir_path = '';
        if nargin < 3
            output_filename = 'simplified_tree.swc';
        end
        [vert, G] = Draw1stable([dir_path 'tree_vert.txt'],...
                                [dir_path 'tree_edge.txt'], 'r', 1, false);
        final_tree = G;
    else
        %   ***Attention*** you might need change file name here.
        [vert, G] = Draw1stable([dir_path 'outvert.txt'],[dir_path 'outedge.txt'],'r',2);
        %%  adjust position and scale if necessary
        disp('transforming graph to original space');
        vert = transformvert(vert, trans, scale);
        % vert(:,2) = 50 - vert(:,2);


        %%  clean with branch - collapse degree 2 edges
        disp('converting to abstract graph');
        %   ToAbstract_branch(Graph, verbose, vertex_list, use_average)
        [absG, edgeG, edgeList, abs_idx] = ToAbstract_branch(G, 0, vert, 0);
        % DrawGraph(absG, vert(abs_idx,:),'k',1);
        disp('computing maximum spanning tree');
        absT = maxspanningtree(absG);
        % hold on;
        % plot3(vert(abs_idx,1),vert(abs_idx,2),vert(abs_idx,3),'b*');
        % DrawGraph(absT, vert(abs_idx,:),'k',1);
        % hold off;


        %%  smooth each branch
        edgeList = s_branch(edgeList, vert, false);
        edgeList = resample_edge(edgeList);


        %%  expand degree 2 edges and select the biggest connected component
        disp('converting back to actual graph');
        [G, vertidx] = ToActual(absT, edgeG, edgeList, vert, 0, abs_idx);
        disp('Selecting connected component');
        if handroot > 0
            [G, handroot] = SimpComponent(G, vert, pos, vertidx);
        else
            G = SimpComponent(G, vert);
        end

        %%  Make up edges
        %   see makeup.m for details
        disp('making up edges');
        restG = logical(absG>1e-6)  - logical(absT>1e-6);
        Gadd = makeup(restG, edgeG, edgeList, vert, 0, abs_idx);
        % idx = find(b{9}==2 | b{9} ==3);
        % hold on;
        % plot3(vert(idx,1),vert(idx,2),vert(idx,3),'r.');
        % hold off;
        % G = saddleclean(G, vert, idx, 1);


        %%  Plot results
        disp('Plotting result');
%         DrawGraph(G, vert, 'b', 1.5);
        DrawGraph(G+Gadd, vert(:, 1:3), 'b', 2);
%         DrawGraph(Gadd, vert, 'k', 2);
        final_tree = G + Gadd;
    end

    %%  Generate files for vaa3D
    disp('writing swc file');
    if handroot > 0
        tt = Tree2SWCtt(final_tree, vert, 2, handroot);
    else
        tt = Tree2SWCtt(final_tree, vert, 2);
    end
    save_v3d_swc_file(tt, ['inputs/' output_filename])
    
    
    %%  Simplify low persistence branches;
%     if ~is_tree
%         persistence_simplification(persist, 0);
%         Morse_Post(1, 'inputs/', output_filename, persist);
%     end
